--- a/Makefile
+++ b/Makefile
@@ -24,10 +24,14 @@
 LOCALEDIR     = $(PREFIX)/share/locale
 BUILDDIR      = $(SRC)
 DESTDIR       = 
-CFLAGS        = -Wall -W -O2
-LDFLAGS       = 
+CFLAGS        = -Wall -W -O2 -m32
+LDFLAGS       = -static
 COPTS         = 
-RPM_OPT_FLAGS = 
+RPM_OPT_FLAGS = -DHAVE_GUARD -DLEASEFILE=\"/tmp/dnsmask.leases\" \
+		-DCONFFILE=\"/tmp/dnsmasq.conf\" \
+		-DRESOLVFILE=\"/tmp/resolv.conf\" \
+		-DRUNFILE=\"/tmp/dnsmasq.pid\"	\
+		-DNO_INOTIFY
 LIBS          = 
 
 #################################################################
@@ -77,7 +81,8 @@
        helper.o tftp.o log.o conntrack.o dhcp6.o rfc3315.o \
        dhcp-common.o outpacket.o radv.o slaac.o auth.o ipset.o \
        domain.o dnssec.o blockdata.o tables.o loop.o inotify.o \
-       poll.o rrfilter.o edns0.o arp.o crypto.o dump.o ubus.o metrics.o
+       poll.o rrfilter.o edns0.o arp.o crypto.o dump.o ubus.o metrics.o \
+       filter.o filter_tree.o filter_alloc.o
 
 hdrs = dnsmasq.h config.h dhcp-protocol.h dhcp6-protocol.h \
        dns-protocol.h radv-protocol.h ip6addr.h metrics.h

--- a/src/config.h
+++ b/src/config.h
@@ -152,6 +152,8 @@
    the default locations of these files are determined below, but may be overridden 
    in a build command line using COPTS.
 
+HAVE_GUARD
+   activate filtering (blacklist/whitelist)
 */
 
 /* Defining this builds a binary which handles time differently and works better on a system without a 
@@ -225,6 +227,15 @@
 #    endif
 #endif
 
+#ifdef HAVE_GUARD
+#    ifndef WHITEFILE
+#        define WHITEFILE "/etc/dnsmasq-white.conf"
+#    endif
+#    ifndef BLACKFILE
+#      define BLACKFILE "/etc/dnsmasq-black.conf"
+#    endif
+#endif
+
 /* platform dependent options: these are determined automatically below
 
 HAVE_LINUX_NETWORK
@@ -419,6 +430,10 @@
 "no-"
 #endif
 "loop-detect "
+#ifndef HAVE_GUARD
+"no-"
+#endif
+"guard "
 #ifndef HAVE_INOTIFY
 "no-"
 #endif

--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -134,6 +134,7 @@
 #ifndef HAVE_LINUX_NETWORK
 #  include <net/if_dl.h>
 #endif
+#include <assert.h>
 
 #if defined(HAVE_LINUX_NETWORK)
 #include <linux/capability.h>
@@ -1052,6 +1053,9 @@
   int dump_mask;
   unsigned long soa_sn, soa_refresh, soa_retry, soa_expiry;
   u32 metrics[__METRIC_MAX];
+#ifdef HAVE_GUARD
+  char dnsreplyip[17]; //="\xc0\x0c\0\x01\0\x01\0\0\0\0\0\x04";
+#endif
 #ifdef OPTION6_PREFIX_CLASS 
   struct prefix_class *prefix_classes;
 #endif
@@ -1612,6 +1616,70 @@
 void poll_listen(int fd, short event);
 int do_poll(int timeout);
 
+/* filter.c */
+#ifdef HAVE_GUARD
+int is_blacklisted(const char *hostname);
+int is_whitelisted(const char *hostname);
+void load_guard(char * response_ip);
+#endif
+
+/* filter_aloc.c */
+#ifdef HAVE_GUARD
+struct s_filter_pool {
+  size_t size;
+  size_t capacity;
+  size_t element_size;
+  void *data;
+};
+
+typedef struct s_filter_pool filter_pool;
+filter_pool *filter_alloc_create_pool(size_t element_size);
+void filter_alloc_destroy_pool(filter_pool *pool);
+int filter_alloc_allocate(filter_pool *pool);
+int filter_alloc_optimize(filter_pool *pool);
+#endif
+
+/* filter_tree.c */
+
+#ifdef HAVE_GUARD
+typedef enum {
+  REDUCE_STAR = -2,
+  REDUCE_ERROR = -1,
+  REDUCE_NUMBER_0 = 0,
+  REDUCE_NUMBER_1,
+  REDUCE_NUMBER_2,
+  REDUCE_NUMBER_3,
+  REDUCE_NUMBER_4,
+  REDUCE_NUMBER_5,
+  REDUCE_NUMBER_6,
+  REDUCE_NUMBER_7,
+  REDUCE_NUMBER_8,
+  REDUCE_NUMBER_9,
+  REDUCE_MINUS,
+  REDUCE_DOT,
+  REDUCE_UNDERSCORE,
+  REDUCE_LETTERS,
+  REDUCE_MAX = REDUCE_LETTERS + 26,
+} __attribute__ ((__packed__)) e_custom_char;
+
+struct node {
+  int sons; /* Offset of the first son from the start of the pool */
+  int next; /* Offset of the next element from the start of the pool */
+  e_custom_char character;
+} __attribute__ ((__packed__));
+
+struct root_node {
+  filter_pool *pool;
+  int first;
+};
+
+struct root_node *filtertree_create();
+int filtertree_add(struct root_node *tree, const char *hostname);
+int filtertree_contains(struct root_node *tree, const char* hostname);
+void filtertree_delete(struct root_node *tree);
+#endif
+
+
 /* rrfilter.c */
 size_t rrfilter(struct dns_header *header, size_t plen, int mode);
 u16 *rrfilter_desc(int type);


--- a/src/forward.c
+++ b/src/forward.c
@@ -1531,6 +1531,33 @@
 	udp_size = PACKETSZ; /* Sanity check - can't reduce below default. RFC 6891 6.2.3 */
     }
 
+#ifdef HAVE_GUARD
+  if (is_blacklisted(daemon->namebuff) || !is_whitelisted(daemon->namebuff))
+    {
+      my_syslog(LOG_DEBUG, "%s blocked", daemon->namebuff);
+      m = 0;
+      daemon->packet[2] |= 128;
+      daemon->packet[7]++;
+      daemon->packet[n] = 192; // Response name
+      daemon->packet[n+1] = 12; // Response name
+      daemon->packet[n+3] = 1; // Response type
+      daemon->packet[n+5] = 1; // Response class
+      daemon->packet[n+11] = 4; // Response data length
+      /** guard-ip (ipv4) **/
+      daemon->packet[n+12] = daemon->dnsreplyip[12];  
+      daemon->packet[n+13] = daemon->dnsreplyip[13];
+      daemon->packet[n+14] = daemon->dnsreplyip[14];
+      daemon->packet[n+15] = daemon->dnsreplyip[15];
+      /** guard-ip (ipv4) **/
+      sendto(listen->fd, daemon->packet, n + 16, 0, &source_addr.in, sizeof(struct sockaddr));
+      return;
+    }
+  else
+    {
+      my_syslog(LOG_DEBUG, "%s passed", daemon->namebuff);
+    }
+#endif
+
 #ifdef HAVE_AUTH
   if (auth_dns)
     {

--- a/src/inotify.c	2018-10-18 14:21:55.000000000 -0400
+++ b/src/inotify.c	2019-01-17 16:42:59.556701192 -0500
@@ -84,7 +84,7 @@
       free(buf);
     }
 }
-
+#ifdef HAVE_INOTIFY
 void inotify_dnsmasq_init()
 {
   struct resolvc *res;
@@ -132,7 +132,7 @@
 	
     }
 }
-
+#endif
 
 /* initialisation for dynamic-dir. Set inotify watch for each directory, and read pre-existing files */
 void set_dynamic_inotify(int flag, int total_size, struct crec **rhash, int revhashsz)

--- a/src/option.c
+++ b/src/option.c
@@ -166,6 +166,9 @@
 #define LOPT_UBUS          354
 #define LOPT_NAME_MATCH    355
 #define LOPT_CAA           356
+#ifdef HAVE_GUARD
+# define LOPT_GUARD_IP     357
+#endif
  
 #ifdef HAVE_GETOPT_LONG
 static const struct option opts[] =  
@@ -337,6 +340,9 @@
     { "dhcp-rapid-commit", 0, 0, LOPT_RAPID_COMMIT },
     { "dumpfile", 1, 0, LOPT_DUMPFILE },
     { "dumpmask", 1, 0, LOPT_DUMPMASK },
+#ifdef HAVE_GUARD
+    { "guard-ip", 1, 0, LOPT_GUARD_IP },
+#endif
     { NULL, 0, 0, 0 }
   };
 
@@ -515,6 +521,9 @@
   { LOPT_RAPID_COMMIT, OPT_RAPID_COMMIT, NULL, gettext_noop("Enables DHCPv4 Rapid Commit option."), NULL },
   { LOPT_DUMPFILE, ARG_ONE, "<path>", gettext_noop("Path to debug packet dump file"), NULL },
   { LOPT_DUMPMASK, ARG_ONE, "<hex>", gettext_noop("Mask which packets to dump"), NULL },
+#ifdef HAVE_GUARD
+  { LOPT_GUARD_IP, ARG_DUP, "[=<ipaddr>]...", gettext_noop("Reply this address on non locally allowed domain"), NULL },
+#endif
   { 0, 0, NULL, NULL, NULL }
 }; 
 
@@ -4397,6 +4406,15 @@
       }
 #endif
 		
+#ifdef HAVE_GUARD
+    case LOPT_GUARD_IP:
+      if (0 >= inet_pton(AF_INET, optarg, &(daemon->dnsreplyip[12]))) {
+	die(_("bad guard ip addr (only IPV4)"), NULL, EC_BADCONF);
+      } else {
+	load_guard(optarg);
+      }
+      break;
+#endif
     default:
       ret_err(_("unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"));
       


