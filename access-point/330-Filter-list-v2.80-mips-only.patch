--- a/Makefile
+++ b/Makefile
@@ -24,10 +24,14 @@
 LOCALEDIR     = $(PREFIX)/share/locale
 BUILDDIR      = $(SRC)
 DESTDIR       = 
-CFLAGS        = -Wall -W -O2
-LDFLAGS       = 
+CFLAGS        = -Wall -W -O2 -m32
+LDFLAGS       = -static
 COPTS         = 
-RPM_OPT_FLAGS = 
+RPM_OPT_FLAGS = -DHAVE_GUARD -DLEASEFILE=\"/tmp/dnsmask.leases\" \
+		-DCONFFILE=\"/tmp/dnsmasq.conf\" \
+		-DRESOLVFILE=\"/tmp/resolv.conf\" \
+		-DRUNFILE=\"/tmp/dnsmasq.pid\"	\
+		-DNO_INOTIFY
 LIBS          = 
 
 #################################################################
@@ -77,7 +81,8 @@
        helper.o tftp.o log.o conntrack.o dhcp6.o rfc3315.o \
        dhcp-common.o outpacket.o radv.o slaac.o auth.o ipset.o \
        domain.o dnssec.o blockdata.o tables.o loop.o inotify.o \
-       poll.o rrfilter.o edns0.o arp.o crypto.o dump.o ubus.o metrics.o
+       poll.o rrfilter.o edns0.o arp.o crypto.o dump.o ubus.o metrics.o \
+       filter.o filter_tree.o filter_alloc.o
 
 hdrs = dnsmasq.h config.h dhcp-protocol.h dhcp6-protocol.h \
        dns-protocol.h radv-protocol.h ip6addr.h metrics.h

--- a/src/config.h
+++ b/src/config.h
@@ -152,6 +152,8 @@
    the default locations of these files are determined below, but may be overridden 
    in a build command line using COPTS.
 
+HAVE_GUARD
+   activate filtering (blacklist/whitelist)
 */
 
 /* Defining this builds a binary which handles time differently and works better on a system without a 
@@ -225,6 +227,15 @@
 #    endif
 #endif
 
+#ifdef HAVE_GUARD
+#    ifndef WHITEFILE
+#        define WHITEFILE "/etc/dnsmasq-white.conf"
+#    endif
+#    ifndef BLACKFILE
+#      define BLACKFILE "/etc/dnsmasq-black.conf"
+#    endif
+#endif
+
 /* platform dependent options: these are determined automatically below
 
 HAVE_LINUX_NETWORK
@@ -419,6 +430,10 @@
 "no-"
 #endif
 "loop-detect "
+#ifndef HAVE_GUARD
+"no-"
+#endif
+"guard "
 #ifndef HAVE_INOTIFY
 "no-"
 #endif

--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -134,6 +134,7 @@
 #ifndef HAVE_LINUX_NETWORK
 #  include <net/if_dl.h>
 #endif
+#include <assert.h>
 
 #if defined(HAVE_LINUX_NETWORK)
 #include <linux/capability.h>
@@ -1052,6 +1053,9 @@
   int dump_mask;
   unsigned long soa_sn, soa_refresh, soa_retry, soa_expiry;
   u32 metrics[__METRIC_MAX];
+#ifdef HAVE_GUARD
+  char dnsreplyip[17]; //="\xc0\x0c\0\x01\0\x01\0\0\0\0\0\x04";
+#endif
 #ifdef OPTION6_PREFIX_CLASS 
   struct prefix_class *prefix_classes;
 #endif
@@ -1612,6 +1616,70 @@
 void poll_listen(int fd, short event);
 int do_poll(int timeout);
 
+/* filter.c */
+#ifdef HAVE_GUARD
+int is_blacklisted(const char *hostname);
+int is_whitelisted(const char *hostname);
+void load_guard(char * response_ip);
+#endif
+
+/* filter_aloc.c */
+#ifdef HAVE_GUARD
+struct s_filter_pool {
+  size_t size;
+  size_t capacity;
+  size_t element_size;
+  void *data;
+};
+
+typedef struct s_filter_pool filter_pool;
+filter_pool *filter_alloc_create_pool(size_t element_size);
+void filter_alloc_destroy_pool(filter_pool *pool);
+int filter_alloc_allocate(filter_pool *pool);
+int filter_alloc_optimize(filter_pool *pool);
+#endif
+
+/* filter_tree.c */
+
+#ifdef HAVE_GUARD
+typedef enum {
+  REDUCE_STAR = -2,
+  REDUCE_ERROR = -1,
+  REDUCE_NUMBER_0 = 0,
+  REDUCE_NUMBER_1,
+  REDUCE_NUMBER_2,
+  REDUCE_NUMBER_3,
+  REDUCE_NUMBER_4,
+  REDUCE_NUMBER_5,
+  REDUCE_NUMBER_6,
+  REDUCE_NUMBER_7,
+  REDUCE_NUMBER_8,
+  REDUCE_NUMBER_9,
+  REDUCE_MINUS,
+  REDUCE_DOT,
+  REDUCE_UNDERSCORE,
+  REDUCE_LETTERS,
+  REDUCE_MAX = REDUCE_LETTERS + 26,
+} __attribute__ ((__packed__)) e_custom_char;
+
+struct node {
+  int sons; /* Offset of the first son from the start of the pool */
+  int next; /* Offset of the next element from the start of the pool */
+  e_custom_char character;
+} __attribute__ ((__packed__));
+
+struct root_node {
+  filter_pool *pool;
+  int first;
+};
+
+struct root_node *filtertree_create();
+int filtertree_add(struct root_node *tree, const char *hostname);
+int filtertree_contains(struct root_node *tree, const char* hostname);
+void filtertree_delete(struct root_node *tree);
+#endif
+
+
 /* rrfilter.c */
 size_t rrfilter(struct dns_header *header, size_t plen, int mode);
 u16 *rrfilter_desc(int type);

--- /dev/null
+++ b/src/filter_alloc.c
@@ -0,0 +1,89 @@
+/* dnsmasq is Copyright (c) 2000-2015 Simon Kelley
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 dated June, 1991, or
+   (at your option) version 3 dated 29 June, 2007.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#ifdef HAVE_GUARD
+
+#include "dnsmasq.h"
+
+filter_pool *filter_alloc_create_pool(size_t element_size) {
+  filter_pool *pool = calloc(1, sizeof(filter_pool));
+  if (pool == NULL )
+    {
+      my_syslog(LOG_ALERT, "Failed to allocate %zu bytes: %s", sizeof(filter_pool), strerror(errno));
+      die("filter_alloc_create_pool: Failed to allocate pool", NULL, 6);
+      return NULL ;
+    }
+
+  pool->element_size = element_size;
+  pool->size = 0;
+  pool->capacity = 1000;
+  pool->data = calloc(pool->capacity, pool->element_size);
+  if (pool->data == NULL )
+    {
+      my_syslog(LOG_ALERT, "Failed to allocate %zu element of %zu bytes: %s"
+	  , pool->capacity
+	  , pool->element_size,
+	  strerror(errno));
+      die("filter_alloc_create_pool: Failed to allocate data pool", NULL, 7);
+    }
+  return pool;
+}
+
+void filter_alloc_destroy_pool(filter_pool *pool) {
+  free(pool->data);
+  free(pool);
+}
+
+int filter_alloc_optimize(filter_pool *pool) {
+  pool->capacity = pool->size;
+  if (pool->capacity == 0)
+    {
+      free(pool->data);
+      pool->data = NULL;
+    } else
+    {
+      pool->data = realloc(pool->data, pool->capacity * pool->element_size);
+      if (pool->data == NULL )
+	{
+	  my_syslog(LOG_ALERT, "Error in opti realloc %zu element of %zu bytes: %s"
+	      , pool->capacity
+	      , pool->element_size
+	      , strerror(errno));
+	  die("filter_alloc_optimize: Failed to realloc", NULL, 8);
+	  return 0;
+	}
+   }
+  return 1;
+}
+
+int filter_alloc_allocate(filter_pool *pool) {
+  if (pool->size >= pool->capacity)
+    {
+      pool->capacity = pool->capacity * 2;
+      pool->data = realloc(pool->data, pool->capacity * pool->element_size);
+      if (pool->data == NULL )
+	{
+	  my_syslog(LOG_ALERT, "Error in grow realloc %zu element of %zu bytes: %s"
+	      , pool->capacity
+	      , pool->element_size
+	      , strerror(errno));
+	  die("filter_alloc_allocate: Failed to realloc", NULL, 8);
+	  return -1;
+	}
+   }
+  return pool->size++;
+}
+
+#endif
--- /dev/null
+++ b/src/filter_tree.c
@@ -0,0 +1,222 @@
+/* dnsmasq is Copyright (c) 2000-2015 Simon Kelley
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 dated June, 1991, or
+   (at your option) version 3 dated 29 June, 2007.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+#ifdef HAVE_GUARD
+
+#include "dnsmasq.h"
+
+#define NODE(pool, offset) (((struct node*)pool->data) + offset)
+
+// > RFC 1034 section 3.5: The labels must follow the rules for ARPANET host
+// > names.  They must start with a letter, end with a letter or digit, and
+// > have as interior characters only letters, digits, and hyphen.  There are
+// > also some restrictions on the length.  Labels must be 63 characters or
+// > less.
+// hash function for node indexation
+static e_custom_char reduce(char c) {
+  if ('0' <= c && c <= '9')
+    return c - '0' + REDUCE_NUMBER_0;
+  if (c == '-')
+    return REDUCE_MINUS;
+  if (c == '.')
+    return REDUCE_DOT;
+  // this char is currently accepted IRL
+  if (c == '_')
+    return REDUCE_UNDERSCORE;
+  if ('a' <= c && c <= 'z')
+    return c - 'a' + REDUCE_LETTERS;
+  if ('A' <= c && c <= 'Z')
+    return c - 'A' + REDUCE_LETTERS;
+  if (c == '*')
+    return REDUCE_STAR;
+
+  return REDUCE_ERROR;
+}
+
+static int get_node(filter_pool *pool, e_custom_char c, int node_index) {
+  int current_node_index = node_index;
+
+  while (current_node_index != -1)
+    {
+      assert((size_t)current_node_index < pool->capacity);
+      struct node *res = NODE(pool, current_node_index);
+      if (res->character == c)
+	{
+	  return current_node_index;
+	}
+      current_node_index = res->next;
+    }
+
+  return -1;
+}
+
+// FIXME: maybe we should insert the node sorted to improve search
+static int insert_node(filter_pool *pool, e_custom_char c, int parent_index) {
+  struct node* parent = NULL;
+  struct node* new_node;
+  int new_node_index;
+
+  assert(parent_index != -1);
+  assert((size_t)parent_index < pool->capacity);
+
+  parent = NODE(pool, parent_index);
+  new_node_index = get_node(pool, c, parent->sons);
+  if (new_node_index != -1)
+    {
+      return new_node_index;
+    }
+
+  // Create new node
+  new_node_index = filter_alloc_allocate(pool);
+  if (new_node_index == -1)
+    {
+      return -1;
+    }
+  new_node = NODE(pool, new_node_index);
+  // Recompute parent pointer, after realloc in allocate from pool, it could have move
+  parent = NODE(pool, parent_index);
+  new_node->character = c;
+  new_node->next = -1;
+  new_node->sons = -1;
+
+  // Insert at head
+  new_node->next = parent->sons;
+  parent->sons = new_node_index;
+
+  return new_node_index;
+}
+
+/**
+ * Add a new hostname in the tree
+ * @param tree
+ * @param hostname
+ * @return
+ */
+int filtertree_add(struct root_node *tree, const char *hostname) {
+  int current_node_index = tree->first;
+  int hostname_len = 0;
+
+  hostname_len = strlen(hostname);
+
+  //If a newline is read, it is stored into the buffer
+  if (hostname[hostname_len - 1] == '\n')
+    hostname_len--;
+
+  for (--hostname_len; hostname_len >= 0; --hostname_len)
+    {
+      int reduced_char = reduce(hostname[hostname_len]);
+      if (reduced_char == REDUCE_ERROR)
+	{
+	  my_syslog(LOG_WARNING, "Bad characters detected: `%c'", hostname[hostname_len]);
+	  return 0;
+	}
+      current_node_index = insert_node(tree->pool, reduced_char, current_node_index);
+      if (current_node_index == -1)
+	{
+	  return -1;
+	}
+    }
+  return 0;
+}
+
+/**
+ * Search if the hostname is inside the tree.
+ * @param tree
+ * @param hostname
+ * @return 1 if node hostname is inside the tree
+ *         0 else
+ */
+int filtertree_contains(struct root_node *tree, const char* hostname) {
+  int current_index = tree->first;
+  int cpt = 0;
+
+  cpt = strlen(hostname);
+  for (--cpt; cpt >= 0; --cpt)
+    {
+      e_custom_char reduced_char = reduce(hostname[cpt]);
+      if (reduced_char == REDUCE_ERROR)
+	{
+	  return 0;
+	}
+      struct node *n = NODE(tree->pool, current_index);
+      if (n->sons != -1 && NODE(tree->pool, n->sons)->character == REDUCE_STAR)
+	{
+	  // Match domain starting with *
+	  // Example:
+	  //    filter: *xample.com
+	  //    host:   example.com
+	  // Example:
+	  //    filter: *.example.com
+	  //    host:   test.example.com
+	  return 1;
+	}
+      current_index = get_node(tree->pool, reduced_char, n->sons);
+      if (current_index == -1)
+	{
+	  return 0;
+	}
+    }
+
+  struct node *n = NODE(tree->pool, current_index);
+  if (n->sons == -1)
+    {
+      // Example:
+      //    filter: example.com
+      //    host:   example.com
+      return 1;
+    }
+
+  // Match simplest domain than filter
+  // Example:
+  //    filter: *.example.com
+  //    host:   example.com
+  if ((current_index = get_node(tree->pool, REDUCE_DOT, n->sons)) >= 0)
+    {
+      n = NODE(tree->pool, current_index);
+      if (n->sons == -1)
+	{
+	  return 0;
+	}
+      if ((current_index = get_node(tree->pool, REDUCE_STAR, n->sons)) >= 0)
+	{
+	  return 1;
+	}
+    }
+
+  return 0;
+}
+
+void filtertree_delete(struct root_node *tree) {
+  filter_alloc_destroy_pool(tree->pool);
+}
+
+struct root_node *filtertree_create() {
+  struct root_node *tree = NULL;
+
+  tree = calloc(1, sizeof(struct root_node));
+  if (tree == NULL )
+    {
+      my_syslog(LOG_ALERT, "Failed to allocate %zu bytes: %s", sizeof(struct root_node), strerror(errno));
+      die("Failed to alloc to create filtertree", NULL, 5);
+      return NULL ;
+    }
+  tree->pool = filter_alloc_create_pool(sizeof(struct node));
+  tree->first = filter_alloc_allocate(tree->pool);
+  struct node *n = NODE(tree->pool, tree->first);
+  n->next = -1;
+  n->sons = -1;
+  return tree;
+}
+#endif

--- /dev/null
+++ b/src/filter.c
@@ -0,0 +1,76 @@
+/* dnsmasq is Copyright (c) 2000-2015 Simon Kelley
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 dated June, 1991, or
+   (at your option) version 3 dated 29 June, 2007.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifdef HAVE_GUARD
+
+#include "dnsmasq.h"
+
+struct root_node* g_whitelist = NULL;
+struct root_node* g_blacklist = NULL;
+
+int is_blacklisted(const char *hostname) {
+  if (g_blacklist == NULL)
+    return 0;
+  return filtertree_contains(g_blacklist, hostname);
+}
+
+int is_whitelisted(const char *hostname) {
+  if (g_whitelist == NULL)
+    return 1;
+  return filtertree_contains(g_whitelist, hostname);
+}
+
+void load_guard(char* response_ip) {
+  int loaded = 0;
+  char buffer[96];
+  FILE * f = fopen(WHITEFILE, "r");
+  if (f) {
+    my_syslog(LOG_NOTICE, _("Loading whitelist file: `%s'"), WHITEFILE);
+    g_whitelist = filtertree_create();
+    while (fgets(buffer, sizeof(buffer), f)) {
+      filtertree_add(g_whitelist, buffer);
+      loaded++;
+    }
+    fclose(f);
+    return;
+  }
+  else {
+    /* Failed to open whitelist, but the file was here */
+    if (errno != ENOENT) {
+      my_syslog(LOG_ERR, _("Failed to load whitelist file: %s, error="), WHITEFILE, strerror(errno));
+    }
+  }
+
+  f = fopen(BLACKFILE, "r");
+  if (f) {
+    my_syslog(LOG_NOTICE, _("Loading blacklist file: `%s'"), BLACKFILE);
+    g_blacklist = filtertree_create();
+    while (fgets(buffer, sizeof(buffer), f)) {
+      filtertree_add(g_blacklist, buffer);
+      loaded++;
+    }
+    fclose(f);
+  }
+  else {
+    /* Failed to open blacklist, but the file was here */
+    if (errno != ENOENT) {
+      my_syslog(LOG_ERR, _("Failed to load blacklist file: %s, error="), BLACKFILE, strerror(errno));
+    }
+  }
+  my_syslog(LOG_INFO, "load %d entries in filterlist\n", loaded);
+}
+
+#endif

--- a/src/forward.c
+++ b/src/forward.c
@@ -1531,6 +1531,33 @@
 	udp_size = PACKETSZ; /* Sanity check - can't reduce below default. RFC 6891 6.2.3 */
     }
 
+#ifdef HAVE_GUARD
+  if (is_blacklisted(daemon->namebuff) || !is_whitelisted(daemon->namebuff))
+    {
+      my_syslog(LOG_DEBUG, "%s blocked", daemon->namebuff);
+      m = 0;
+      daemon->packet[2] |= 128;
+      daemon->packet[7]++;
+      daemon->packet[n] = 192; // Response name
+      daemon->packet[n+1] = 12; // Response name
+      daemon->packet[n+3] = 1; // Response type
+      daemon->packet[n+5] = 1; // Response class
+      daemon->packet[n+11] = 4; // Response data length
+      /** guard-ip (ipv4) **/
+      daemon->packet[n+12] = daemon->dnsreplyip[12];  
+      daemon->packet[n+13] = daemon->dnsreplyip[13];
+      daemon->packet[n+14] = daemon->dnsreplyip[14];
+      daemon->packet[n+15] = daemon->dnsreplyip[15];
+      /** guard-ip (ipv4) **/
+      sendto(listen->fd, daemon->packet, n + 16, 0, &source_addr.in, sizeof(struct sockaddr));
+      return;
+    }
+  else
+    {
+      my_syslog(LOG_DEBUG, "%s passed", daemon->namebuff);
+    }
+#endif
+
 #ifdef HAVE_AUTH
   if (auth_dns)
     {

--- a/src/inotify.c	2018-10-18 14:21:55.000000000 -0400
+++ b/src/inotify.c	2019-01-17 16:42:59.556701192 -0500
@@ -84,7 +84,7 @@
       free(buf);
     }
 }
-
+#ifdef HAVE_INOTIFY
 void inotify_dnsmasq_init()
 {
   struct resolvc *res;
@@ -132,7 +132,7 @@
 	
     }
 }
-
+#endif
 
 /* initialisation for dynamic-dir. Set inotify watch for each directory, and read pre-existing files */
 void set_dynamic_inotify(int flag, int total_size, struct crec **rhash, int revhashsz)

--- a/src/option.c
+++ b/src/option.c
@@ -166,6 +166,9 @@
 #define LOPT_UBUS          354
 #define LOPT_NAME_MATCH    355
 #define LOPT_CAA           356
+#ifdef HAVE_GUARD
+# define LOPT_GUARD_IP     357
+#endif
  
 #ifdef HAVE_GETOPT_LONG
 static const struct option opts[] =  
@@ -337,6 +340,9 @@
     { "dhcp-rapid-commit", 0, 0, LOPT_RAPID_COMMIT },
     { "dumpfile", 1, 0, LOPT_DUMPFILE },
     { "dumpmask", 1, 0, LOPT_DUMPMASK },
+#ifdef HAVE_GUARD
+    { "guard-ip", 1, 0, LOPT_GUARD_IP },
+#endif
     { NULL, 0, 0, 0 }
   };
 
@@ -515,6 +521,9 @@
   { LOPT_RAPID_COMMIT, OPT_RAPID_COMMIT, NULL, gettext_noop("Enables DHCPv4 Rapid Commit option."), NULL },
   { LOPT_DUMPFILE, ARG_ONE, "<path>", gettext_noop("Path to debug packet dump file"), NULL },
   { LOPT_DUMPMASK, ARG_ONE, "<hex>", gettext_noop("Mask which packets to dump"), NULL },
+#ifdef HAVE_GUARD
+  { LOPT_GUARD_IP, ARG_DUP, "[=<ipaddr>]...", gettext_noop("Reply this address on non locally allowed domain"), NULL },
+#endif
   { 0, 0, NULL, NULL, NULL }
 }; 
 
@@ -4397,6 +4406,15 @@
       }
 #endif
 		
+#ifdef HAVE_GUARD
+    case LOPT_GUARD_IP:
+      if (0 >= inet_pton(AF_INET, optarg, &(daemon->dnsreplyip[12]))) {
+	die(_("bad guard ip addr (only IPV4)"), NULL, EC_BADCONF);
+      } else {
+	load_guard(optarg);
+      }
+      break;
+#endif
     default:
       ret_err(_("unsupported option (check that dnsmasq was compiled with DHCP/TFTP/DNSSEC/DBus support)"));
       


